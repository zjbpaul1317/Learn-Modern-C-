## 常量
**nullptr**
`nullptr`出现是为了替代`NULL`,C与C++中有空指针常量，它们能被隐式转换成任何指针类型的空指针值或C++中的任何成员指针类型的空成员指针值.
`NULL`由标准库提供，并被定义为实现定义的空指针常量，在C中，有些标准库会把`NULL`定义为`((void*)0)`，而有些将它定义为0

C++不允许直接将`void*`隐式转换到其他类型，从而`((void*)0)`不是NULL的合法实现，如果标准库尝试把NULL定义为`((void*)0)`，那么下面这行代码会出现编译错误：
```
char *ch = NULL;
```

没有了`void*`隐式转换的C++只好将`NULL`定义为0，但这会产生新的问题：将导致C++中重载特性发生混乱，如下面两个`foo`函数：
```
void foo(char *);
void foo(int);
```
那么`foo(NULL)`，这行代码将会去调用`foo(int)`，从而导致代码违反直觉

为了解决这个问题，C++11 引入了`nullptr`关键字，专门用来区分空指针、0。而`nullptr`的类型为 `nullptr_t`，能够隐式的转换为任何指针或成员指针的类型，也能和他们进行相等或者不等的比较。

**constexpr**
C++ 本身已经具备了常量表达式的概念，比如`1+2`, `3*4`这种表达式总是会产生相同的结果并且没有任何副作用。如果编译器能够在编译时就把这些表达式直接优化并植入到程序运行时，将能增加程序的性能。一个非常明显的例子就是在数组的定义阶段：
< learn_constexpr.cpp

< 注意，现在大部分编译器其实都带有自身编译优化，很多非法行为在编译器优化的加持下会变得合法，若需重现编译报错的现象需要使用老版本的编译器。

C++11提供了`constexpr` 让用户显式的声明函数或对象构造函数在编译期会成为常量表达式，这个关键字明确的告诉编译器应该去验证`len_foo`在编译器就应该是一个常量表达式

此外，`constexpr`修饰的函数可以使用递归:
```
constexpr int fibonacci(const int n)
{
    return n == 1 || n == 2 ? 1 : fibonacci(n-1)+fibonacci(n-2);
}
```

从C++14开始，`constexpr`函数可以在内部使用局部变量、循环和分支等简单语句，下面的代码在C++11标准下是不能通过编译的：
```
constexpr int fibonacci(const int n)
{
    if(n == 1)  return 1;
    if(n == 2)  return 1;
    return fibonacci(n-1) + fibonacci(n-2);
}
```


