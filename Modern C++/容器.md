# 容器
## 线性容器
**std::arrary**
看到这个容器的时候肯定会出现这样的问题：
1. 为什么要引入`std::array`而不是直接使用`std::vector`？
2. 已经有了传统数组，为什么要用`std::array`?

第一个问题，与`std::vector`不同，`std::array`对象的大小是固定的，如果容器大小是固定的，那么可以优先考虑使用`std::array`容器；另外由于`std::vector`是自动扩容的，当存入大量的数据后，并且对容器进行了删除操作，容器并不会自动归还被删除元素相应的内存，这时候需要手动运行`shrink_to_fit()`释放这部分内存
```
std::vector<int> v;
std::cout << v.size() << std::endl;
std::cout << v.capacity() << std::endl;

v.push_back(1);
v.push_back(2);
v.push_back(3);
std::cout << v.size() << std::endl;
std::cout << v.capacity() << std::endl;

v.push_back(4);
v.push_back(5);
std::cout << v.size() << std::endl;
std::cout << v.capacity() << std::endl;

v.clear();
std::cout << v.size() << std::endl;
std::cout << v.capacity() << std::endl;

v.shrink_to_fit();
std::cout << v.size() << std::endl;
std::cout << v.capacity() << std::endl;
```

第二个问题，使用`std::array`能够让代码变得更加"现代化"，而且封装了一些操作函数，比如获取数组大小以及检查是否非空，同时还能够友好地使用标准库中的容器算法，比如`std::sort`
使用`std::array`很简单，只需要指定其类型和大小即可：
```
std::array<int, 4> arr = {1, 2, 3, 4};
arr.empty();  //检查容器是否为空
arr.size();   //返回容纳的元素数

//迭代器支持
for(auto &i : arr)
{
    //...
}

//用lambda表达式排序
std::sort(arr.begin(), arr.end(), [](int a, int b) {
    return b < a;
});

//数组大小参数必须是常量表达式
constexpr int len = 4;
std::array<int, len> arr = {1, 2, 3, 4};

//非法，不同于C风格数组，std::array不会自动退化成T*
//int *arr_p = arr;
```
当使用`std::array`后，难免会遇到要将其兼容C风格的接口，这里有三种做法:
```
void foo(int *p, int len) 
{
    return;
}

std::array<int, 4> arr = {1,2,3,4};

// C 风格接口传参
// foo(arr, arr.size()); // 非法, 无法隐式转换
foo(&arr[0], arr.size());
foo(arr.data(), arr.size());

// 使用 `std::sort`
std::sort(arr.begin(), arr.end());
```





